
程序从test.cpp开始进入。

根据播放源加载不同的播放服务。
播放服务分为：
vod，点播服务（该视频由其他电脑/服务器提供，接收TS流，可以随意调控进度）
live，直播服务（无法调控进度，全由直播源发来视频）
local，本地播放影片（影片在本地保存着，不受网络限制影响，可以随意调控进度）

本地播放打开双流，即同时两个线程读取视频源，一个播放音频，一个播放视频。

点播和直播则只打开一个视频文件流，为了防止网速卡顿。

点播大致流程（有结束）：
打开目录文件->根据文件格式配置播放参数->打开两个线程（音频回调和视频回调）->将视频文件部分内容写入缓存->回调函数不断反复读取缓存中内容进行播放->文件播放结束，同时结束两个回调函数

直播大致流程（无结束）：
打开目录文件->根据文件格式配置播放参数->打开两个线程（音频回调和视频回调）->将视频文件部分内容写入缓存->回调函数不断反复读取缓存中内容进行播放

本地大致流程（有结束）：
打开目录文件->根据文件格式配置播放参数->打开音频线程->以音频播放速度为准，主进程只播放视频画面（无将视频帧放入缓存步骤，即拆包即播）->音频回调函数不断反复读取缓存中内容进行播放->文件播放结束，音频结束，结束两个回调函数

音频预先加载：
在音频回调函数不断播放缓存中的音频时， “本地服务的音频线程" 或 “直播点播的主进程” 会提前将要播的内容输入缓存，等待音频播到一定进度后，将先前播放完的一部分音频清除，才进行下一次缓存。

什么是回调函数？
编程人员通过某些方式开启回调函数，
比如sdl的音频的开启函数openaudio()，开启后会反复使用回调函数。
每两次回调函数的使用时间间隔固定为0.01秒，即每次使用回调函数都会播放0.01秒的音频内容。（如果你couti显示回调函数中len参数大小，会发现len越大，播放速度越快）
所以我自己又根据“音频回调函数的原理”编了个“视频回调函数”。
这样我解包后就不用马上播放视频帧，而是将视频帧的包先存储到 包列表（pVpacket[bufnumber]）（即缓存）里，等待视频函数不断调取缓存中内容进行播放。

